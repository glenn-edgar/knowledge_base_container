from typing import Optional, Callable, Dict, Any
import time
import threading

import paho.mqtt.client as mqtt


class MqttToPostgresBridge:
    """
    Bridges all MQTT messages to Postgres using an existing MqttPostgresMirror.

    Init args:
      - mirror: an instantiated MqttPostgresMirror (already holds a psycopg2 connection)
      - host: MQTT broker hostname / IP
      - port: MQTT broker TCP port (default 1883)
      - username: optional MQTT username (default None)
      - password: optional MQTT password (default None)
      - client_id: optional MQTT client ID (default auto-generated by paho)
      - pre_store_hook: optional callable(topic, payload_bytes, qos, retain, props, client_id, packet_id, content_type)
                        -> dict | None
                        Return a dict to override fields (e.g. {"payload": b"...", "content_type": "application/json"}),
                        or {"skip": True} to drop the message before storage.
      - keepalive: MQTT keepalive seconds (default 60)
      - clean_session: True for a fresh session (default True)

    Methods:
      - start(): connect, subscribe to '#', begin background network loop
      - fetch_all_queued(timeout_s=5.0): process network events for up to timeout_s seconds,
                                         useful to pull in retained messages immediately after subscribe
      - stop(): stop background loop and disconnect
      - close(): stop MQTT and close the Postgres connection inside mirror
    """

    def __init__(
        self,
        *,
        mirror,
        host: str,
        port: int = 1883,
        username: Optional[str] = None,
        password: Optional[str] = None,
        client_id: Optional[str] = None,
        pre_store_hook: Optional[
            Callable[[str, bytes, int, bool, Optional[Dict[str, Any]], Optional[str], Optional[int], Optional[str]],
                     Optional[Dict[str, Any]]]
        ] = None,
        keepalive: int = 60,
        clean_session: bool = True,
    ):
        self.mirror = mirror
        self.host = host
        self.port = int(port)
        self.username = username
        self.password = password
        self.client_id = client_id
        self.keepalive = int(keepalive)
        self.clean_session = bool(clean_session)
        self.pre_store_hook = pre_store_hook

        # Internal state / counters (no logging module as requested)
        self.connected = False
        self.subscribed = threading.Event()
        self.last_sub_mid = None
        self.msg_count = 0
        self._loop_running = False

        # MQTT client (v3.1.1 by default; change to MQTTv5 if you want native properties)
        self.client = mqtt.Client(client_id=self.client_id, clean_session=self.clean_session, protocol=mqtt.MQTTv311)
        if self.username is not None:
            self.client.username_pw_set(self.username, self.password)

        # Callbacks
        self.client.on_connect = self._on_connect
        self.client.on_disconnect = self._on_disconnect
        self.client.on_subscribe = self._on_subscribe
        self.client.on_message = self._on_message

    # ---------- Public control ----------

    def start(self) -> None:
        """Connect, subscribe to '#', and start the background network loop."""
        # Connect
        self.client.connect(self.host, self.port, keepalive=self.keepalive)
        # Start network loop in background thread
        self.client.loop_start()
        self._loop_running = True

    def fetch_all_queued(self, timeout_s: float = 5.0) -> int:
        """
        Drain/process network events for up to timeout_s seconds.
        Useful to receive retained messages after the initial subscribe.
        Returns the number of messages processed during this call (best effort).
        """
        start = time.time()
        start_count = self.msg_count

        # Wait until we are subscribed (or timeout)
        while not self.subscribed.is_set() and (time.time() - start) < timeout_s:
            time.sleep(0.01)

        # Temporarily run a tight manual loop (even if loop_start is running)
        # Paho is thread-safe for loop() calls; keep these short.
        while (time.time() - start) < timeout_s:
            # This processes network events once; returns MQTT_ERR_SUCCESS/AGAIN.
            self.client.loop(timeout=0.05)
            time.sleep(0.01)

